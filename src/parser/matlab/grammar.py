#!/usr/bin/env python
#
# @file    grammar.py
# @brief   Core of the MATLAB grammar definition in PyParsing
# @author  Michael Hucka
#
# <!---------------------------------------------------------------------------
# This software is part of MOCCASIN, the Model ODE Converter for Creating
# Awesome SBML INteroperability. Visit https://github.com/sbmlteam/moccasin/.
#
# Copyright (C) 2014 jointly by the following organizations:
#  1. California Institute of Technology, Pasadena, CA, USA
#  2. Mount Sinai School of Medicine, New York, NY, USA
#
# This is free software; you can redistribute it and/or modify it under the
# terms of the GNU Lesser General Public License as published by the Free
# Software Foundation.  A copy of the license agreement is provided in the
# file named "COPYING.txt" included with this software distribution and also
# available online at https://github.com/sbmlteam/moccasin/.
# ------------------------------------------------------------------------- -->

# Summary of basic principles.
# .............................................................................
#
# This module defines a class, MatlabGrammar, for parsing MATLAB files.  The
# main entry point is MatlabGrammar.parse_string(...).  There are a few other
# public methods on MatlabGrammar for debugging and other tasks, but the
# basic goal of MatlabGrammar is to provide MatlabGrammar.parse_string(...),
# a function to produce a data structure that a caller can examine to
# determine what was found in a given MATLAB file.
#
# First thing to know: the ParseResults objects generated by this
# PyParsing-based parser are heavily nested and annotated.  This is annoying
# to traverse by hand, and even more annoying to print (you will a *lot* of
# output for even simple things).  More on that below.
#
# The second thing to note is that the grammar is designed to attach
# PyParsing "result names" to matched components.  What this means is that
# most ParseResults objects have a Python dictionary associated with them.
# You can use Python's keys() operator to inspect the dictionary keys on most
# objects.  The basic approach to using the parsing results thus becomes a
# matter of using keys() to find out the entry or entries on an object,
# accessing the dictionary entries using the keys, calling keys() on the
# result of *that*, and so on, recursively.
#
# Here's an example using a simple assignment.  Suppose a file contains this:
#
#     a = 1
#
# MatlabGrammar.parse_string(...) will return one ParseResults object at the
# top level, but this object will in reality be a recursively-structured list
# of annotated ParseResults objects.  (This will hopefully become more clear
# as this example progresses.)  At the top level, there will be one object
# per line in the file.  To find out how many there are, you can look at the
# length of what was returned by MatlabGrammar.parse_string(...):
#
#     (Pdb) type(results)
#     <class 'pyparsing.ParseResults'>
#     (Pdb) len(results)
#     1
#
# In this example, there's only one line in the file, so the length of the
# ParseResults object is one.  Let's get the ParseResults object for that
# first line:
#
#     (Pdb) content = results[0]
#     (Pdb) content.keys()
#     ['assignment']
#
# This first line of the file was labeled as an 'assignment', which is
# MatlabGrammar's way of identifying (you guessed it) an assignment
# statement.  Now let's look inside of it:
#
#     (Pdb) content['assignment'].keys()
#     ['rhs', 'lhs']
#
# The object stored under the dictionary key 'assignment' has its own
# dictionary, and that dictionary has two entries: one under the key 'lhs'
# (for the left-hand side of the assignment) and another under the key 'rhs'
# (for the right-hand side).  You can access each of these individually:
#
#     (Pdb) content['assignment']['lhs'].keys()
#     ['identifier']
#
# This now says that the object keyed by 'lhs' in the content['assignment']
# ParseResults object has another dictionary, with a single item stored under
# the key 'identifier'.  'identifier' is one of the terminal entities in
# MatlabGrammar.  When you access its value, you will find it's not a
# ParseResults object, but a string:
#
#     (Pdb) content['assignment']['lhs']['identifier']
#     'a'
#
# And there it is: the name of the variable on the left-hand side of the
# assignment in the file.  If we repeat the process for the right-hand side
# of the assignment, we find the following:
#
#     (Pdb) content['assignment']['rhs'].keys()
#     ['number']
#     (Pdb) content['assignment']['rhs']['number']
#     '1'
#
# The key 'number' corresponds to another terminal entity in MatlabGrammar.
# Its value is (you guessed it again) a number.  Note that the values
# returned by MatlabGrammar are always strings, so even though it could in
# principle be returned in the form of a numerical data type, MatlabGrammar
# does not do that, because doing so might require data type conversions and
# such conversions might require decisions that are best left to the
# applications calling MatlabGrammar.  So instead, it always returns
# everything in finds in a MATLAB file as a text string.
#
# Now, let's examine what happens if we have something slightly more
# complicated in the file, such as the following:
#
#     a = [1 2; 3 4]
#
# This is an assignment to a matrix that has two rows, each of which have two
# items.  Applying MatlabGrammar.parse_string(...) to this input will once
# again yield a ParseResults object that itself contains a list of
# ParseResults objects, where the list will only have length one.  If we
# access the object,
#
#     (Pdb) content = results[0]
#     (Pdb) content.keys()
#     ['assignment']
#
# we once again have an assignment, as expected.  Let's take a look at the
# right-hand side of this one:
#
#     (Pdb) content['assignment']['rhs'].keys()
#     ['matrix']
#
# This time, MatlabGrammar has helpfully identified the object on the
# right-hand side as a matrix.  Let's traverse the structure it produced:
#
#     (Pdb) matrix = content['assignment']['rhs']['matrix']
#     (Pdb) matrix.keys()
#     ['row list']
#     (Pdb) matrix['row list'].keys()
#     []
#
# This time, the object has no keys.  The reason for this is the following:
# some objects stored under the dictionary keys are actually lists.  The name
# 'row list' is meant to suggest this possibility.  When a value created by
# MatlabGrammar is a list, the first thing to do is to find out its length:
#
#     (Pdb) len(matrix['row list'])
#     2
#
# What this means is that the matrix has two row entries stored in a list
# keyed by 'row list'.  Accessing them is simple:
#
#     (Pdb) row1 = matrix['row list'][0]
#     (Pdb) row2 = matrix['row list'][1]
#     (Pdb) row1.keys()
#     ['index list']
#     (Pdb) row2.keys()
#     ['index list']
#
# Both of them have lists of their own.  These work in the same way as the
# row lists: you first find out their length, and then index into them to get
# the values.
#
#     (Pdb) len(row1)
#     2
#     (Pdb) row1[0].keys()
#     ['number']
#     (Pdb) row1[0]['number']
#     '1'
#
# As expected, we are down to the terminal parts of the expression, and here
# we have indexed into the first element of the first row of the matrix.  All
# of the rest of the entries in the matrix are accessed in the same way.  For
# example,
#
#     (Pdb) row2[1].keys()
#     ['number']
#     (Pdb) row2[1]['number']
#     '4'
#
# As a final example, let's take a look at a mathematical expression.
# Suppose our file contains the following:
#
#     a = 1 + 2
#
# As usual, applying MatlabGrammar.parse_string(...) to this input will once
# again yield a ParseResults object that itself contains a list of
# ParseResults objects, and once again the list will only have length 1
# because there is only one line in the file.  If we access the first object,
#
#     (Pdb) content = results[0]
#     (Pdb) content.keys()
#     ['assignment']
#
# we once again have an assignment, as expected.  Let's take a look at the
# right-hand side of this one:
#
#     (Pdb) content['assignment']['rhs'].keys()
#     []
#
# This time, the right-hand side does not have a key.  This is the tip-off
# that the right-hand side is an expression: in MatlabGrammar, if there is no
# key on an object, it means that the object is an expression or a list.
# Expressions are lists: when you encounter them, it means the next step is
# to iterate over the elements.
#
#     (Pdb) len(content['assignment']['rhs'])
#     3
#     (Pdb) content['assignment']['rhs'][0].keys()
#     ['number']
#     (Pdb) content['assignment']['rhs'][1].keys()
#     ['binary operator']
#     (Pdb) content['assignment']['rhs'][2].keys()
#     ['number']
#
# In this simple expression, the elements inside the expression list are
# terminal objects, but in general, they could be anything, including more
# expressions.  The rule for traversing expressions is the same: inspect the
# keys of each object, do whatever is appropriate for kind of object it is,
# and if there are no keys, it's another expression, so traverse it
# recursively.
#
# And that summarizes the basic process for working with MatlabGrammar parse
# results.  MatlabGrammar.parse_string(...) returns a list of objects results
# for the lines in the file; each has a dictionary, which you inspect to
# figure out what kind of objects were extracted, and then you dig into the
# object's dictionaries recursively until you reach terminal entities.
# Sometimes the values for dictionaries are lists, in which case you iterate
# over the values, applying the same principle.


# Preface material.
# .............................................................................

import sys
import pdb
import pyparsing                        # Need this for version check, so DON'T
from pyparsing import *                 # ... MERGE THIS and previous stmt!
from distutils.version import LooseVersion
from grammar_utils import *
from scope import *

# Check minimum version of PyParsing.

if LooseVersion(pyparsing.__version__) < LooseVersion('2.0.3'):
    raise Exception('MatlabGrammar requires PyParsing version 2.0.3 or higher')

# Necessary optimization.  Without this, the PyParsing grammar defined below
# never finishes parsing anything.

ParserElement.enablePackrat()


# MatlabGrammar.
# .............................................................................

class MatlabGrammar:

    # Context and scope management.
    #
    # In Matlab, an input file will be either a script, or a function
    # definition.  A script is distinguished from a function definition
    # simply by not starting with "function ..." (after any initial comments
    # in the file).
    #
    # Files can contain nested function definitions.  Each of these sets up
    # scopes, inside of which can be more matlab commands such as variable
    # assignments.  For our purposes, we're particularly interested in
    # tracking functions, so the scope-tracking scheme in grammar.py is
    # organized around function definitions.
    #
    # Scopes are recorded by annotating the ParseResults objects returned by
    # the PyParsing parser with an attribute called 'scope', containing a
    # Scope object.  This object's main role is to organize the data we need
    # to track without attaching a whole lot of separate fields directly on
    # the ParseResults objects.
    #
    # To track nested function definitions, grammar.py has a notion of
    # "contexts".  A context is a Scope object.  It holds the functions,
    # variables and other definitions found at a particular level of nesting.
    # A Scope object also holds the ParseResults object returned by the
    # parser for that level.
    #
    # The outermost context is the file, and for that, we initialize the
    # context-tracking mechanism with a blank ParseResults object.  Each time
    # a new function declaration is encountered, another context is "pushed".
    # The context pushed is a Scope object containing the ParseResults object
    # returned by our PyParsing for a function definition.  When an 'end'
    # statement is encountered in the input, the current context is popped.
    #
    # At the end of a parse, we return the ParseResults object returned by
    # the PyParsing framework with an added attribute, 'scope', containing a
    # Scope object instance.  The scope object will have fields for such
    # things as functions defined in the file.
    # .........................................................................

    def _push_context(self, newscope):
        newscope.parent = self._scope
        self._scope = newscope


    def _pop_context(self):
        # Don't pop top-most scope.
        if self._scope.parent:
            self._scope = self._scope.parent


    def _duplicate_context(self, dest):
        if not dest.scope:
            dest.scope = Scope()
        dest.scope.copy_scope(self._scope)


    def _save_function_definition(self, content, pr):
        name = content['name']['identifier']
        params = []
        if 'parameter list' in content.keys():
            params = [term[0] for term in content['parameter list']]
        outputs = []
        if 'output list' in content.keys():
            outputs = [term[0] for term in content['output list']]
        newscope = Scope(name, self._scope, pr, params, outputs)
        self._scope.functions[name] = newscope
        return newscope


    def _save_assignment(self, content):
        key = MatlabGrammar.make_key(content['lhs'])
        rhs = content['rhs']
        self._scope.assignments[key] = rhs


    def _save_function_call(self, content):
        if 'name' in content.keys():
            name_part = content['name']
            if 'cell array' in name_part.keys():
                # FIXME this is not right -- need handle this properly
                name = name_part['cell array']['name']
            elif 'identifier' in name_part.keys():
                name = name_part['identifier']
        self._scope.calls[name] = content['argument list']


    def _save_type(self, thing, type):
        self._scope.types[thing] = type


    def _get_type(self, thing):
        if thing in self._scope.types:
            return self._scope.types[thing]
        else:
            return None


    # Grammar functions.
    # .........................................................................

    # The following gets called *after* a grammar element has been parsed by
    # PyParsing.

    def _store_stmt(self, pr):
        if not isinstance(pr, ParseResults):
            return
        if 'assignment' in pr.keys():
            content = pr['assignment']
            self._save_assignment(content)
        elif 'function definition' in pr.keys():
            content = pr['function definition']
            self._push_context(self._save_function_definition(content, pr))
        elif 'end statement' in pr.keys():
            self._pop_context()
        elif 'matrix or function' in pr.keys():
            # This could be a matrix value access or a function call.
            # Syntactically, we can't tell the difference. Treat them as calls.
            content = pr['matrix or function']
            self._save_function_call(content)


    def _remember_type(self, pr):
        if not isinstance(pr, ParseResults):
            return
        if 'assignment' in pr:
            lhs = pr['assignment']['lhs']
            rhs = pr['assignment']['rhs']
            if 'identifier' in lhs:
                if {'matrix', 'number', 'boolean', 'string'} & set(rhs.keys()):
                    self._save_type(lhs['identifier'], 'variable')
            elif 'matrix' in lhs:
                matrix = lhs['matrix']
                if 'name' in matrix:
                    self._save_type(name['identifier'], 'variable')
        elif 'function definition':
            func = pr['function definition']
            if 'output list' in func:
                for var in func['output list']:
                    # The output parameter names are a safe bet to assume to
                    # be variables.
                    self._save_type(var['identifier'], 'variable')
            if 'parameter list' in func:
                for param in func['parameter list']:
                    # FIXME this labels parameters as variables, but the
                    # parameter could be a function name or handle when it's
                    # called.  Need to correlate what's done here with the
                    # arguments used in the call to the function.
                    self._save_type(param['identifier'], 'variable')


    def _convert_type(self, pr):
        if not isinstance(pr, ParseResults) or 'matrix or function' not in pr:
            return
        content = pr['matrix or function']
        if 'name' in content:
            if self._get_type(content['name']['identifier']) == 'variable':
                # We have seen this name before, and it's not a function.
                content = pr.pop('matrix or function')
                pr['matrix'] = content
                content['index list'] = content.pop('argument list')


    # Start of grammar definition.
    #
    # Note: this is written in reverse order, from smallest elements to the
    # highest level parsing object, simply because Python interprets the file
    # in this order and needs each item defined before it encounters it
    # later.  However, for readabily, it's probably easiest to start at the
    # last definition (which is _matlab_syntax) and read up.
    #
    # First, the lowest-level terminal tokens.
    # .........................................................................

    _EOL        = LineEnd().suppress()
    _SOL        = LineStart().suppress()
    _WHITE      = White(ws=' \t')

    _SEMI       = Literal(';').suppress()
    _COMMA      = Literal(',').suppress()
    _LPAR       = Literal("(").suppress()
    _RPAR       = Literal(")").suppress()
    _LBRACKET   = Literal('[').suppress()
    _RBRACKET   = Literal(']').suppress()
    _LBRACE     = Literal('{').suppress()
    _RBRACE     = Literal('}').suppress()
    _EQUALS     = Literal('=').suppress()
    _DOT        = Literal('.').suppress()
    _ELLIPSIS   = Literal('...')

    # This definition of numbers knowingly ignores imaginary numbers because
    # they're not used in our domain.

    _INTEGER    = Word(nums)
    _EXPONENT   = Combine(oneOf('E e D d') + Optional(oneOf('+ -')) + Word(nums))
    _FLOAT      = (Combine(Word(nums) + Optional('.' + Word(nums)) + _EXPONENT)
                   | Combine(Word(nums) + '.' + _EXPONENT)
                   | Combine(Word(nums) + '.' + Word(nums))
                   | Combine('.' + Word(nums) + _EXPONENT)
                   | Combine('.' + Word(nums)))

    # Next come definitions of terminal elements.  The funky syntax with the
    # second parenthesized argument on each line is something PyParsing allows;
    # it's a short form, equivalent to calling .setResultsName(...).

    _NUMBER     = (_FLOAT | _INTEGER)                 ('number')
    _BOOLEAN    = (Keyword('true') | Keyword('false'))('boolean')
    _STRING     = QuotedString("'", escQuote="''")    ('string')

    _ID         = Word(alphas, alphanums + '_')       ('identifier')
    _TILDE      = Literal('~')                        ('tilde')

    _UMINUS     = Literal('-')                        ('unary operator')
    _UPLUS      = Literal('+')                        ('unary operator')
    _UNOT       = Literal('~')                        ('unary operator')
    _TIMES      = Literal('*')                        ('binary operator')
    _ELTIMES    = Literal('.*')                       ('binary operator')
    _MRDIVIDE   = Literal('/')                        ('binary operator')
    _MLDIVIDE   = Literal('\\')                       ('binary operator')
    _RDIVIDE    = Literal('./')                       ('binary operator')
    _LDIVIDE    = Literal('.\\')                      ('binary operator')
    _MPOWER     = Literal('^')                        ('binary operator')
    _ELPOWER    = Literal('.^')                       ('binary operator')
    _PLUS       = Literal('+')                        ('binary operator')
    _MINUS      = Literal('-')                        ('binary operator')
    _LT         = Literal('<')                        ('binary operator')
    _LE         = Literal('<=')                       ('binary operator')
    _GT         = Literal('>')                        ('binary operator')
    _GE         = Literal('>=')                       ('binary operator')
    _EQ         = Literal('==')                       ('binary operator')
    _NE         = Literal('~=')                       ('binary operator')
    _AND        = Literal('&')                        ('binary operator')
    _OR         = Literal('|')                        ('binary operator')
    _SHORT_AND  = Literal('&&')                       ('binary operator')
    _SHORT_OR   = Literal('||')                       ('binary operator')

    # Operators that have special-case handling.

    _COLON      = Literal(':')
    _NC_TRANSP  = Literal(".'")
    _CC_TRANSP  = Literal("'")

    # Basic keywords.

    _BREAK      = Keyword('break')                     ('keyword')
    _CASE       = Keyword('case')                      ('keyword')
    _CATCH      = Keyword('catch')                     ('keyword')
    _CLASSDEF   = Keyword('classdef')                  ('keyword')
    _CONTINUE   = Keyword('continue')                  ('keyword')
    _ELSE       = Keyword('else')                      ('keyword')
    _ELSEIF     = Keyword('elseif')                    ('keyword')
    _END        = Keyword('end')                       ('keyword')
    _FOR        = Keyword('for')                       ('keyword')
    _FUNCTION   = Keyword('function')                  ('keyword')
    _GLOBAL     = Keyword('global')                    ('keyword')
    _IF         = Keyword('if')                        ('keyword')
    _OTHERWISE  = Keyword('otherwise')                 ('keyword')
    _PARFOR     = Keyword('parfor')                    ('keyword')
    _PERSISTENT = Keyword('persistent')                ('keyword')
    _RETURN     = Keyword('return')                    ('keyword')
    _SWITCH     = Keyword('switch')                    ('keyword')
    _TRY        = Keyword('try')                       ('keyword')
    _WHILE      = Keyword('while')                     ('keyword')

    # Grammar for expressions.
    #
    # Some up-front notes:
    #
    # 1) Calling PyParsing's setResultsName() function or its equivalent
    # yields A COPY of the thing affected -- it does not return the original
    # thing.  This means that if you have a grammar element of the form
    #             _foo = Group(_bar('bar') | _biff('biff'))
    # then _bar and _biff never actually get invoked when _foo is invoked;
    # what get invoked are copies of _bar and _biff, because that's what gets
    # stored in _foo.  This has implications for our use of _store_stmt()
    # further below: setting a name on _bar & _biff as above causes copies of
    # _bar and _biff to be used in _foo, which means _bar and _biff never get
    # called, which means _store_stmt() is never called either.  This leads
    # to subtle and frustrating rounds of bug-chasing.
    #
    # 2) The grammar below is sometimes designed with the assumption that the
    # input is valid Matlab.  This fits our purpose, which is to parse valid
    # Matlab, so we can afford to produce something simpler here and assume
    # that the input won't do some things that the Matlab parser would
    # reject.  The basic rule is: accept everything that's valid Matlab, but
    # don't worry about deliberately excluding what isn't valid Matlab.
    # .........................................................................

    _expr          = Forward()

    # The possible statement separators/delimiters in Matlab are:
    #   - EOL
    #   - line comment (because they eat the EOL at the end)
    #   - block comments
    #   - semicolon
    #   - comma
    # We handle EOL implicitly in most cases by leaving PyParsing's default
    # whitespace definition as-is, which marks EOL as an ignored whitespace
    # character. However, sometimes Matlab syntax requires special care with
    # EOL, so in those cases, EOL is handled explicitly.

    _delimiter     = _COMMA | _SEMI

    _line_c_start  = Literal('%').suppress()
    _block_c_start = Literal('%{').suppress()
    _block_c_end   = Literal('%}').suppress()
    _line_comment  = Group(_line_c_start + restOfLine + _EOL)
    _block_comment = Group(_block_c_start + SkipTo(_block_c_end, include=True))
    _comment       = Group(_block_comment('comment') | _line_comment('comment'))

    # Comma-separated arguments to matrix/array/cell constructs can have ':'
    # in arguments, but arguments to function calls can't.  Parameter lists in
    # some other situations (like function return values) can have '~', but
    # the other elements can only be identifiers, not expressions.  The
    # following are the different versions used in different places later on.
    #
    # For this to work, the next bunch of grammar objects have to be
    # constructed with different whitespace-handling rules: they must not eat
    # line breaks, because we need to match EOL explicitly, or else we can't
    # properly parse a matrix like the following as consisting of 2 rows:
    #    a = [1 2
    #         3 4]
    # That's the reason for the next call to setDefaultWhitespaceChars().
    # This is turned off again further below.

    ParserElement.setDefaultWhitespaceChars(' \t')

    _one_index     = Group(_COLON('colon')) | _expr
    _comma_indexes = _one_index + ZeroOrMore(_COMMA + _one_index)
    _space_indexes = _one_index + ZeroOrMore(_WHITE.suppress() + _one_index).leaveWhitespace()
    _call_args     = delimitedList(_expr)
    _fun_params    = delimitedList(Group(_TILDE) | Group(_ID))

    # Bare matrices.  This is a cheat because it doesn't check that all the
    # element contents have the same data type.  But again, since we expect our
    # input to be valid Matlab, we don't expect to have to verify that property.

    _row_sep       = _SEMI | _EOL | _comment.suppress()
    _one_row       = _comma_indexes('index list') ^ _space_indexes('index list')
    _rows          = Group(_one_row) + ZeroOrMore(_row_sep + Group(_one_row))
    _bare_matrix   = Group(_LBRACKET + Optional(_rows('row list')) + _RBRACKET
                          ).setResultsName('matrix')  # noqa

    ParserElement.setDefaultWhitespaceChars(' \t\n\r')

    # Cell arrays.  You can write {} by itself, but a reference has to have at
    # least one indexing term: "somearray{}" is not valid.  Newlines don't
    # seem to be allowed in args to references, but a bare ':' is allowed.
    # Now the hard parts:
    # - The following parses as a cell reference:        a{1}
    # - The following parses as a function call:         a {1}
    # - The following parses as an array of 3 elements:  [a {1} a]

    _bare_cell     = Group(_LBRACE + ZeroOrMore(_rows('row list')) + _RBRACE
                          ).setResultsName('cell array')  # noqa
    _cell_name     = Group(_ID)
    _cell_access   = Group(_cell_name('name') + _LBRACE.leaveWhitespace()
                           + OneOrMore(_rows('row list')) + _RBRACE
                          ).setResultsName('cell array')  # noqa
    _cell_array    = _cell_access | _bare_cell

    # Matlab functions can be called with arguments that are either
    # surrounded with parentheses or not.  In other words, if you define a
    # function 'f' in a file, you can actually call it two ways:
    #    f(x)
    #    f x
    # Spaces are allowed in the first form too:
    #    f (x)
    # Unfortunately, the forms using parentheses look identical to matrix
    # accesses, and there's no way to tell them apart except by determining
    # whether 'f' is a function or command.  This means it's ultimately
    # run-time dependent, and depends on the functions and scripts that the
    # user has defined.  In the case of array references, you can use bare
    # ':' in the argument list.  This means that if a ':' is found, it's an
    # array reference for sure -- possibly helping to disambiguate some
    # cases.  For that reason, the ':' case is split out below.  Not yet sure
    # if it's worth it.
    #
    # Another complication: you can put function names or matrices inside a
    # cell array, reference into the array, and hand it arguments.  E.g.:
    #    x = fcnArray{3}(y)
    #    x = somearray{1}(2,3)
    # That's the reason for _cell_access in the definition of _fun_access.

    _fun_mat_name  = Group(_ID)
    _fun_access    = _fun_mat_name ^ Group(_cell_access('cell array'))
    _fun_mat_call  = Group(_fun_access('name')
                           + _LPAR + _call_args('argument list') + _RPAR
                          ).setResultsName('matrix or function')  # noqa

    _matrix_name   = Group(_ID)
    _matrix_args   = Group(_comma_indexes)
    _matrix_access = Group(_matrix_name('name')
                           + _LPAR + _matrix_args('index list') + _RPAR
                          ).setResultsName('matrix')  # noqa

    # Func. handles: http://www.mathworks.com/help/matlab/ref/function_handle.html
    # In all function arguments, you can use a bare tilde to indicate a value
    # that can be ignored.  This is not obvious from the functional
    # documentation, but it seems to be the case when I try it.  (It's the
    # case for function defs and function return values too.)

    _handle_name   = Group(_ID)
    _named_handle  = Group('@' + _handle_name('name'))
    _anon_handle   = Group('@' + _LPAR + _call_args('argument list')
                           + _RPAR + _expr('function definition'))  # noqa
    _fun_handle    = (_named_handle | _anon_handle).setResultsName('function handle')

    # Struct array references.  This is incomplete: in Matlab, the LHS can
    # actually be a full expression that yields a struct.  Here, to avoid an
    # infinitely recursive grammar, we only allow a specific set of objects
    # and exclude a full expr.  (Doing the obvious thing, expr + "." + _ID,
    # results in an infinitely-recursive grammar.)

    _struct_base   = Group(_cell_access
                           | _fun_mat_call
                           | _matrix_access
                           | _fun_handle
                           | _ID)
    _struct_field  = Group(_ID)
    _struct_access = Group(_struct_base('struct base')
                           + _DOT.leaveWhitespace() + _struct_field('field')
                          ).setResultsName('struct')  # noqa

    # The transpose operator is a problem.  You can actually apply it to full
    # expressions, but I haven't been able to write a grammar that doesn't
    # lead to infinite recursion.  This hacky thing is a partial solution.

    _paren_expr    = _LPAR + _expr + _RPAR
    _transp_what   = _paren_expr ^ Group(_cell_array
                                         | _fun_mat_call
                                         | _bare_matrix
                                         | _matrix_access
                                         | _fun_handle
                                         | _BOOLEAN | _ID | _NUMBER | _STRING)
    _transpose_op  = _NC_TRANSP ^ _CC_TRANSP
    _transpose     = Group(_transp_what('operand') + _transpose_op('operator')
                          ).setResultsName('transpose')  # noqa

    # And now, general expressions and operators.

    _operand       = Group(_struct_access
                           | _transpose
                           | _bare_matrix
                           | _fun_mat_call
                           | _matrix_access
                           | _cell_array
                           | _fun_handle
                           | _BOOLEAN | _ID | _NUMBER | _STRING)

    # The operator precedence rules in Matlab are listed here:
    # http://www.mathworks.com/help/matlab/matlab_prog/operator-precedence.html

    # FIXME: colon operator for 3 arguments is wrong.

    _plusminus     = _PLUS ^ _MINUS
    _uplusminusneg = _UMINUS ^ _UPLUS ^ _UNOT
    _timesdiv      = _TIMES ^ _ELTIMES ^ _MRDIVIDE ^ _MLDIVIDE ^ _RDIVIDE ^ _LDIVIDE
    _power         = _MPOWER ^ _ELPOWER
    _logical_op    = _LT ^ _LE ^ _GT ^ _GE ^ _EQ ^ _NE
    _colon_op      = _COLON('colon operator')

    _expr          << infixNotation(_operand, [
        (Group(_uplusminusneg), 1, opAssoc.RIGHT),
        (Group(_power),         2, opAssoc.LEFT, makeLRlike(2)),
        (Group(_timesdiv),      2, opAssoc.LEFT, makeLRlike(2)),
        (Group(_plusminus),     2, opAssoc.LEFT, makeLRlike(2)),
        (Group(_colon_op),      2, opAssoc.LEFT, makeLRlike(2)),
        (Group(_logical_op),    2, opAssoc.LEFT, makeLRlike(2)),
        (Group(_AND),           2, opAssoc.LEFT, makeLRlike(2)),
        (Group(_OR),            2, opAssoc.LEFT, makeLRlike(2)),
        (Group(_SHORT_AND),     2, opAssoc.LEFT, makeLRlike(2)),
        (Group(_SHORT_OR),      2, opAssoc.LEFT, makeLRlike(2)),
    ])

    _cond_expr     = infixNotation(_operand, [
        (Group(_logical_op),    2, opAssoc.LEFT, makeLRlike(2)),
        (Group(_AND),           2, opAssoc.LEFT, makeLRlike(2)),
        (Group(_OR),            2, opAssoc.LEFT, makeLRlike(2)),
        (Group(_SHORT_AND),     2, opAssoc.LEFT, makeLRlike(2)),
        (Group(_SHORT_OR),      2, opAssoc.LEFT, makeLRlike(2)),
    ])

    # Assignments.  We tag the LHS with 'lhs' whether it's a single variable
    # or an array, because we can distinguish the cases by examining the
    # parsed object.

    _lhs_var        = Group(_ID)
    _simple_assign  = Group(_lhs_var('lhs') + _EQUALS + _expr('rhs'))
    _lhs_array      = Group(_bare_matrix | _matrix_access | _cell_array | _struct_access)
    _other_assign   = Group(_lhs_array('lhs') + _EQUALS + _expr('rhs'))
    _assignment     = (_other_assign | _simple_assign).setResultsName('assignment')

    # Control statements.
    # FIXME: this should be full statements, not line-oriented.

    _cond           = Group(_cond_expr)                   ('condition')
    _while_stmt     = Group(_WHILE + _cond)               ('while statement')
    _if_stmt        = Group(_IF + _cond)                  ('if statement')
    _elseif_stmt    = Group(_ELSEIF + _cond)              ('elseif statement')
    _loop_var       = Group(_ID)                          ('loop variable')
    _for_stmt       = Group(_FOR + _loop_var + _EQUALS
                            + _expr('expression'))        ('for statement')
    _switch_stmt    = Group(_SWITCH + _expr('expression'))('switch statement')
    _case_stmt      = Group(_CASE + _expr('expression'))  ('case statement')
    _catch_var      = Group(_ID)                          ('catch variable')
    _catch_stmt     = Group(_CATCH + _catch_var)          ('catch statement')
    _otherwise_stmt = _OTHERWISE                          ('otherwise statement')
    _else_stmt      = _ELSE                               ('else statement')
    _end_stmt       = _END                                ('end statement')
    _try_stmt       = _TRY                                ('try statement')
    _continue_stmt  = _CONTINUE                           ('continue statement')
    _break_stmt     = _BREAK                              ('break statement')
    _return_stmt    = _RETURN                             ('return statement')

    _control_stmt   = Group(_while_stmt
                            | _if_stmt
                            | _else_stmt
                            | _elseif_stmt
                            | _switch_stmt
                            | _case_stmt
                            | _otherwise_stmt
                            | _for_stmt
                            | _try_stmt
                            | _catch_stmt
                            | _continue_stmt
                            | _break_stmt
                            | _return_stmt
                            | _end_stmt
                           ).setResultsName('control statement')  # noqa

    # When a function returns multiple values and the LHS is an array
    # expression in square brackets, a bare tilde can be put in place of an
    # argument value to indicate that the value is to be ignored.

    _single_value   = Group(_ID) | Group(_TILDE)
    _comma_values   = delimitedList(_single_value)
    _space_values   = OneOrMore(_single_value)
    _multi_values   = _LBRACKET + (_comma_values ^ _space_values) + _RBRACKET
    _fun_outputs    = Group(_multi_values) | Group(_single_value)
    _fun_paramslist = _LPAR + Optional(_fun_params) + _RPAR
    _fun_name       = Group(_ID)
    _fun_def_stmt   = Group(_FUNCTION.suppress()
                            + Optional(_fun_outputs('output list') + _EQUALS())
                            + _fun_name('name')
                            + Optional(_fun_paramslist('parameter list'))
                           ).setResultsName('function definition')  # noqa

    # Shell commands don't respect ellipses or delimiters, so we use EOL
    # explicitly here and match _shell_cmd at the _matlab_syntax level.

    _shell_cmd_cmd  = Group(restOfLine)('command')
    _shell_cmd      = Group(Group('!' + _shell_cmd_cmd + _EOL)('shell command'))

    # Matlab commands (and function calls) can take unquoted arguments:
    #    clear x y z
    #    format long
    #    print -dpng magicsquare.png
    #    save /tmp/foo
    #    save relative/path.m
    # etc.  The same ones take other forms, like pause(n), but those will get
    # caught by the regular function call grammar.  They respect delimiters.
    #
    # Some of these are problematic.  Consider a command line like this:
    #    save /tmp/foo
    # This actually looks exactly like
    #    a/b/c
    # i.e., a numerical expression, with the '/' meaning division, and
    # "save", "tmp" and "foo" being variables.  I'm not even sure how Matlab
    # does it.  The cases could be differentiated based on knowing that "save"
    # is a command, but then you would have to know about all commands that
    # can take file paths as arguments.  Doable, but fragile -- some future
    # Matlab version could introduce more such commands.
    #
    # The grammar below probably doesn't handle all cases correctly because I
    # haven't figured out what to do about this.  This relies on the order in
    # which it's attempted to be matched by _stmt, and in particular, this has
    # to be tried before trying _expr.

    ParserElement.setDefaultWhitespaceChars(' \t')

    _noncmd_start = _EQUALS | _LPAR | _delimiter | _comment
    _cmd_name     = Group(_ID)
    _cmd_args     = Group(SkipTo(_delimiter | _comment | _EOL))
    _cmd_stmt     = Group(_cmd_name('name')
                          + FollowedBy(_WHITE + NotAny(_noncmd_start))
                          + _cmd_args('arguments')
                         ).setResultsName('command statement')  # noqa

    ParserElement.setDefaultWhitespaceChars(' \t\n\r')

    # The definition of _stmt puts all statement types except _shell_cmd
    # together and sets them up to allow ellipsis continuations.

    _continuation  = Combine(_ELLIPSIS.leaveWhitespace() + _EOL + _SOL)

    _stmt = Group(_fun_def_stmt | _control_stmt | _assignment
                  | _cmd_stmt | _expr('expression'))
    _stmt.ignore(_continuation)

    # Finally, we bring it all together into the root element of our grammar.

    _matlab_syntax = ZeroOrMore(_stmt ^ _shell_cmd ^ _delimiter ^ _comment)


    # Store certain constructs for easier access.
    # .........................................................................

    def _init_parse_actions(self):
        self._fun_def_stmt  .addParseAction(self._store_stmt)
        self._fun_mat_call  .addParseAction(self._store_stmt)
        self._assignment    .addParseAction(self._store_stmt)
        self._cmd_stmt      .addParseAction(self._store_stmt)
        self._end_stmt      .addParseAction(self._store_stmt)


    # Add actions to support weak data type inferencing
    # .........................................................................

    def _init_type_inference(self):
        self._assignment    .addParseAction(self._remember_type)
        self._fun_def_stmt  .addParseAction(self._remember_type)
        self._fun_mat_call  .addParseAction(self._convert_type)


    # Debugging.
    # .........................................................................

    # Name each grammar object after itself, so that when PyParsing prints
    # debugging output, it uses the name rather than a generic regexp term.

    _to_name = [_AND, _BOOLEAN, _BREAK, _CASE, _CATCH, _CC_TRANSP,
                _CLASSDEF, _COLON, _COMMA, _CONTINUE, _DOT, _ELLIPSIS,
                _ELPOWER, _ELSE, _ELSEIF, _ELTIMES, _END, _EOL, _EQ,
                _EQUALS, _EXPONENT, _FLOAT, _FOR, _FUNCTION, _GE, _GLOBAL,
                _GT, _ID, _IF, _INTEGER, _LBRACE, _LBRACKET, _LDIVIDE, _LE,
                _LPAR, _LT, _MINUS, _MLDIVIDE, _MPOWER, _MRDIVIDE,
                _NC_TRANSP, _NE, _NUMBER, _OR, _OTHERWISE, _PARFOR,
                _PERSISTENT, _PLUS, _RBRACE, _RBRACKET, _RDIVIDE, _RETURN,
                _RPAR, _SEMI, _SHORT_AND, _SHORT_OR, _SOL, _STRING, _SWITCH,
                _TILDE, _TIMES, _TRY, _UMINUS, _UNOT, _UPLUS, _WHILE,
                _WHITE, _anon_handle, _assignment, _bare_cell, _bare_matrix,
                _block_c_end, _block_c_start, _block_comment, _call_args,
                _case_stmt, _catch_stmt, _cell_access, _cell_array,
                _cell_name, _cmd_args, _cmd_name, _cmd_stmt, _comma_indexes,
                _comma_values, _comment, _cond_expr, _continuation,
                _control_stmt, _delimiter, _elseif_stmt, _expr, _for_stmt,
                _fun_access, _fun_def_stmt, _fun_handle, _fun_mat_call,
                _fun_mat_name, _fun_name, _fun_outputs, _fun_params,
                _fun_paramslist, _handle_name, _if_stmt, _lhs_array,
                _lhs_var, _line_c_start, _line_comment, _logical_op,
                _matlab_syntax, _matrix_access, _matrix_args, _matrix_name,
                _multi_values, _named_handle, _noncmd_start, _one_row,
                _operand, _other_assign, _otherwise_stmt, _paren_expr,
                _plusminus, _power, _row_sep, _rows, _shell_cmd,
                _shell_cmd_cmd, _simple_assign, _single_value,
                _space_indexes, _space_values, _stmt, _struct_access,
                _struct_base, _struct_field, _switch_stmt, _timesdiv,
                _transp_what, _transpose, _transpose_op, _try_stmt,
                _uplusminusneg, _while_stmt, _otherwise_stmt, _else_stmt,
                _end_stmt, _continue_stmt, _break_stmt, _return_stmt
                ]


    def _object_name(self, obj):
        """Returns the name of a given object."""
        for name, thing in MatlabGrammar.__dict__.iteritems():
            if thing is obj:
                return name

    def _init_grammar_names(self):
        map(lambda x: x.setName(self._object_name(x)), self._to_name)

    # The next variable and function support the "print interpreted" option
    # for the parser interface.

    _to_print = [_comment, _stmt, _shell_cmd]

    def _init_print_interpreted(self):
        map(lambda x: x.addParseAction(self._print_tokens), self._to_print)


    def _set_print_tokens(self, doprint):
        self._do_print_tokens = doprint


    def _print_tokens(self, tokens):
        # This gets called once for every matching line.
        # Tokens will be a list; the first element will be the variable.
        if self._do_print_tokens:
            print tokens


    # The next variable and functino are for printing low-level PyParsing
    # matches.  To use this, manually add objects to the list, like so:
    #   _to_print_raw = [_cell_access, _cell_array, _bare_cell, _expr]
    _to_print_raw = []

    def _init_print_raw(self):
        map(lambda x: x.setDebug(True), self._to_print_raw)


    # Printers, for more debugging.
    # .........................................................................

    def _warn(self, *args):
        print('WARNING: {}'.format(' '.join(args)))


    def _init_printer(self):
        self._stringifiers = {'assignment':          self._format_assignment,
                              'identifier':          self._format_identifier,
                              'number':              self._format_number,
                              'boolean':             self._format_boolean,
                              'string':              self._format_string,
                              'tilde':               self._format_tilde,
                              'unary operator':      self._format_op,
                              'binary operator':     self._format_op,
                              'colon operator':      self._format_op,
                              'colon':               self._format_colon,
                              'function handle':     self._format_fun_handle,
                              'function definition': self._format_fun_def,
                              'cell array':          self._format_cell_array,
                              'struct':              self._format_struct,
                              'matrix':              self._format_matrix,
                              'matrix or function':  self._format_matrix_or_fun,
                              'transpose':           self._format_transpose,
                              'shell command':       self._format_shell,
                              'command statement':   self._format_cmd_stmt,
                              'control statement':   self._format_control_stmt,
                              'comment':             self._format_comment,
                              'while statement':     self._format_while_stmt,
                              'if statement':        self._format_if_stmt,
                              'elseif statement':    self._format_elseif_stmt,
                              'else statement':      self._format_else_stmt,
                              'switch statement':    self._format_switch_stmt,
                              'case statement':      self._format_case_stmt,
                              'otherwise statement': self._format_otherwise_stmt,
                              'for statement':       self._format_for_stmt,
                              'try statement':       self._format_try_stmt,
                              'catch statement':     self._format_catch_stmt,
                              'continue statement':  self._format_continue_stmt,
                              'break statement':     self._format_break_stmt,
                              'return statement':    self._format_return_stmt,
                              'end statement':       self._format_end_stmt,
                              'expression':          self._format_expression
                              }


    def _stringify(self, thing):
        return '\n'.join([self._format_pr(pr) for pr in thing])


    def _format_pr(self, pr):
        if isinstance(pr, str):
            return pr
        if len(pr.keys()) == 0:
            # It's an expression.
            return self._format_expression(pr)
        stringifier = self._stringifiers[pr.keys()[0]]
        return stringifier(pr)


    def _format_identifier(self, pr):
        if not self._verified_pr(pr, 'identifier'):
            return
        content = pr['identifier']
        return '{{identifier: "{}"}}'.format(content)


    def _format_number(self, pr):
        if not self._verified_pr(pr, 'number'):
            return
        content = pr['number']
        return '{{number: {}}}'.format(content)


    def _format_boolean(self, pr):
        if not self._verified_pr(pr, 'boolean'):
            return
        content = pr['boolean']
        return '{{boolean: {}}}'.format(content)


    def _format_op(self, pr):
        if not {'unary operator', 'binary operator',
                'colon operator'} & set(pr.keys()):
            self._warn('ParseResults not an operator type')
        op_key = pr.keys()[0]
        if 'colon operator' in pr.keys():
            text = '{colon}'
        else:
            if 'unary operator' in pr.keys():
                op = 'unary op'
            elif 'binary operator' in pr.keys():
                op = 'binary op'
            text = '{{{}: {}}}'.format(op, pr[op_key])
        return text


    def _format_string(self, pr):
        if not self._verified_pr(pr, 'string'):
            return
        content = pr['string']
        return '{{string: "{}"}}'.format(content)


    def _format_assignment(self, pr):
        if not self._verified_pr(pr, 'assignment'):
            return
        content = pr['assignment']
        lhs = content['lhs']
        rhs = content['rhs']
        return '{{assign: {} = {}}}'.format(self._format_pr(lhs),
                                            self._format_pr(rhs))


    def _format_simple_list(self, pr):
        return ', '.join([self._format_pr(thing) for thing in pr])


    def _format_matrix_or_fun(self, pr):
        if not self._verified_pr(pr, 'matrix or function'):
            return
        content = pr['matrix or function']
        name = content['name']
        args = self._format_simple_list(content['argument list'])
        return '{{function/matrix: {} ( {} )}}'.format(self._format_pr(name), args)


    def _stringify_indexes(self, indexes):
        return ', '.join([self._format_pr(thing) for thing in indexes])


    def _stringify_rowlist(self, arglist):
        last = len(arglist) - 1
        i = 1
        text = ''
        for row in arglist:
            if 'index list' not in row.keys():
                self._warn('did not find index list key ParseResults')
                return 'ERROR'
            indexes = row['index list']
            text += '{{row {}: {}}}'.format(i, self._stringify_indexes(indexes))
            if i <= last:
                text += '; '
            i += 1
        return text


    def _format_matrix(self, pr):
        if not self._verified_pr(pr, 'matrix'):
            return
        content = pr['matrix']
        # Two kinds of matrix situations: a bare matrix, and one where we
        # managed to determine it's a matrix access (and not the more
        # ambiguous function call or matrix access).  If we have a row list,
        # it's the former; if we have an index list, it's the latter.
        if 'row list' in content.keys():
            rows = self._stringify_rowlist(content['row list'])
            return '{{matrix: [ {} ]}}'.format(rows)
        elif 'index list' in content.keys():
            name = self._format_pr(content['name'])
            indexes = self._stringify_indexes(content['index list'])
            return '{{matrix {}: [ {} ]}}'.format(name, indexes)
        else:
            # No row list or index list => empty matrix.
            return '{{matrix: [] }}'


    def _format_cell_array(self, pr):
        if not self._verified_pr(pr, 'cell array'):
            return
        content = pr['cell array']
        rows = self._stringify_rowlist(content['row list'])
        if 'name' in content.keys():
            name = content['name']
            return '{{cell array: {} [ {} ]}}'.format(self._format_pr(name), rows)
        else:
            return '{{cell array: [ {} ]}}'.format(rows)


    def _format_fun_def(self, pr):
        if not self._verified_pr(pr, 'function definition'):
            return
        content = pr['function definition']
        name = self._format_pr(content['name'])
        if 'output list' in content.keys():
            output = self._format_simple_list(content['output list'])
            if len(content['output list']) > 1:
                output = '[ ' + output + ' ]'
        else:
            output = 'none'
        if 'parameter list' in content.keys():
            param = self._format_simple_list(content['parameter list'])
        else:
            param = 'none'
        return '{{function definition: {} parameters ( {} ) output {}}}' \
            .format(name, param, output)


    def _format_fun_handle(self, pr):
        if not self._verified_pr(pr, 'function handle'):
            return
        content = pr['function handle']
        if 'name' in content.keys():
            name = content['name']
            return '{{function @ handle: {}}}'.format(self._format_pr(name))
        else:
            # No name => anonymous function
            arg_list = self._format_simple_list(content['argument list'])
            body = self._format_pr(content['function definition'])
            return '{{anon @ handle: args ( {} ) body {} }}'.format(arg_list, body)


    def _format_struct(self, pr):
        if not self._verified_pr(pr, 'struct'):
            return
        content = pr['struct']
        base = self._format_pr(content['struct base'])
        field = self._format_pr(content['field'])
        return '{{struct: {}.{} }}'.format(base, field)


    def _format_colon(self, pr):
        if not self._verified_pr(pr, 'colon'):
            return
        return '{colon}'


    def _format_transpose(self, pr):
        if not self._verified_pr(pr, 'transpose'):
            return
        content = pr['transpose']
        operand = self._format_pr(content['operand'])
        return '{{transpose: {} operator {} }}'.format(operand, content['operator'])


    def _format_shell(self, pr):
        if not self._verified_pr(pr, 'shell command'):
            return
        content = pr['shell command']
        body = content['command'][0]
        return '{{shell command: {}}}'.format(body)


    def _format_cmd_stmt(self, pr):
        if not self._verified_pr(pr, 'command statement'):
            return
        content = pr['command statement']
        name = self._format_pr(content['name'])
        args = content['arguments'][0]
        return '{{command: name {} args {}}}'.format(name, args)


    def _format_comment(self, pr):
        if not self._verified_pr(pr, 'comment'):
            return
        content = pr['comment']
        return '{{comment: {}}}'.format(content[0])


    def _format_control_stmt(self, pr):
        if not self._verified_pr(pr, 'control statement'):
            return
        content = pr['control statement']
        return self._format_pr(content)


    def _format_while_stmt(self, pr):
        if not self._verified_pr(pr, 'while statement'):
            return
        content = pr['while statement']
        cond = self._format_pr(content['condition'])
        return '{{while stmt: {}}}'.format(cond)


    def _format_if_stmt(self, pr):
        if not self._verified_pr(pr, 'if statement'):
            return
        content = pr['if statement']
        cond = self._format_pr(content['condition'])
        return '{{if stmt: {}}}'.format(cond)


    def _format_elseif_stmt(self, pr):
        if not self._verified_pr(pr, 'elseif statement'):
            return
        content = pr['elseif statement']
        cond = self._format_pr(content['condition'])
        return '{{eleif stmt: {}}}'.format(cond)


    def _format_else_stmt(self, pr):
        if not self._verified_pr(pr, 'else statement'):
            return
        return '{else}'


    def _format_switch_stmt(self, pr):
        if not self._verified_pr(pr, 'switch statement'):
            return
        content = pr['switch statement']
        expr = self._format_pr(content['expression'])
        return '{{switch stmt: {}}}'.format(expr)


    def _format_case_stmt(self, pr):
        if not self._verified_pr(pr, 'case statement'):
            return
        content = pr['case statement']
        expr = self._format_pr(content['expression'])
        return '{{case: {}}}'.format(expr)


    def _format_otherwise_stmt(self, pr):
        if not self._verified_pr(pr, 'otherwise statement'):
            return
        return '{otherwise}'


    def _format_for_stmt(self, pr):
        if not self._verified_pr(pr, 'for statement'):
            return
        content = pr['for statement']
        var = self._format_pr(content['loop variable'])
        exp = self._format_pr(content['expression'])
        return '{{for stmt: var {} in {}}}'.format(var, exp)


    def _format_try_stmt(self, pr):
        if not self._verified_pr(pr, 'try statement'):
            return
        return '{try}'


    def _format_catch_stmt(self, pr):
        if not self._verified_pr(pr, 'catch statement'):
            return
        content = pr['catch statement']
        var = self._format_pr(content['catch variable'])
        return '{{catch: var {}}}'.format(var)


    def _format_continue_stmt(self, pr):
        if not self._verified_pr(pr, 'continue statement'):
            return
        return '{continue}'


    def _format_break_stmt(self, pr):
        if not self._verified_pr(pr, 'break statement'):
            return
        return '{break}'


    def _format_return_stmt(self, pr):
        if not self._verified_pr(pr, 'return statement'):
            return
        return '{return}'


    def _format_end_stmt(self, pr):
        if not self._verified_pr(pr, 'end statement'):
            return
        return '{end}'


    def _format_tilde(self, pr):
        if not self._verified_pr(pr, 'tilde'):
            return
        return '{tilde}'


    def _format_expression(self, thing):
        return '( ' + ' '.join([self._format_pr(pr) for pr in thing]) + ' )'


    def _verified_pr(self, pr, type):
        if len(pr) > 1:
            self._warn('expected 1 ParseResults, but got {}'.format(len(pr)))
            return False
        if type not in pr.keys():
            self._warn('ParseResults not of type {}'.format(type))
            return False
        return True


    # Instance initialization.
    # .........................................................................

    def __init__(self):
        self._reset()
        self._init_grammar_names()
        self._init_parse_actions()
        self._init_type_inference()
        self._init_print_interpreted()
        self._init_print_raw()
        self._init_printer()


    def _reset(self):
        self._do_print_tokens = False
        self._scope           = None
        self._push_context(Scope('(outermost scope)'))


    # External interfaces.
    # .........................................................................

    def parse_string(self, input, print_debug=False, fail_soft=False):
        '''Parses MATLAB input and returns an annotated ParseResults object.

        :param print_debug: if True, print debug output as each line is parsed.
        :param fail_soft: if True, don't raise an exception if parsing fails.

        '''
        self._reset()
        self._set_print_tokens(print_debug)
        try:
            pr = self._matlab_syntax.parseString(input, parseAll=True)
            self._duplicate_context(pr)
            return pr
        except ParseException as err:
            msg = "Error: {0}".format(err)
            if fail_soft:
                print(msg)
                return None
            else:
                raise err


    def interpret_parse_results(self, results):
        '''Returns a string describing the interpretation of a ParseResults
        object returned by MatlabGrammar.parse_string().  This is intended
        for debugging purposes; the output is not particularly suited for any
        other purpose.  The parameter 'results' must be a ParseResults object
        as returned by MatlabGrammar's parse_string() function, or this
        function will raise a ValueError.
        '''
        if not isinstance(results, ParseResults) or not results.scope:
            raise ValueError('Argument must be a MatlabGrammar parse result.')
        return self._stringify(results)


    def print_parse_results(self, results):
        '''Prints an interpreted version of a MatlabGrammar parse result.
        This is intended for debugging purposes; the output is not
        particularly suited for any other purpose.  The parameter 'results'
        must be a ParseResults object as returned by MatlabGrammar's
        parse_string() function, or this function will raise a ValueError.

        '''
        if not isinstance(results, ParseResults) or not results.scope:
            raise ValueError('Argument must be a MatlabGrammar parse result.')
        print(self.interpret_parse_results(results))


    @staticmethod
    def make_key(thing):
        '''Turns a parsed object like a matrix into a canonical text-string
        form, for use as a key in dictionaries such as Scope.assignments.
        '''
        def terminal(thing):
            return {'identifier', 'number', 'colon', 'tilde', 'string',
                    'boolean', 'colon operator', 'unary operator', 'binary',
                    'operator'} & set(thing.keys())

        def row_to_string(row):
            list = []
            for item in row:
                if terminal(item) and len(item.keys()) == 1:
                    list.append(item[item.keys()[0]])
                elif 'matrix or function' in item or 'matrix' in item \
                     or 'cell array' in item or 'struct' in item:
                    list.append(MatlabGrammar.make_key(item))
                elif not item.keys():
                    list.append(MatlabGrammar.make_formula(item, False, False))
            return ','.join(list)

        if not isinstance(thing, ParseResults):
            return None
        elif terminal(thing) and len(thing.keys()) == 1:
            return thing[thing.keys()[0]]
        elif 'matrix' in thing:
            matrix = thing['matrix']
            if 'row list' in matrix:
                # Bare matrix, like [a,b].
                rowlist = [row_to_string(row['index list']) for row in matrix['row list']]
                return '[' + ';'.join(rowlist) + ']'
            elif 'index list' in matrix:
                # Matrix reference, like foo(2,3).
                name = matrix['name']['identifier']
                return name + '(' + row_to_string(matrix['index list']) + ')'
        elif 'matrix or function' in thing:
            func = thing['matrix or function']
            name = func['name']['identifier']
            return name + '(' + row_to_string(func['argument list']) + ')'
        elif 'cell array' in thing:
            # Cell array accesses may have names.
            array = thing['cell array']
            if 'name' in array:
                name = array['name']['identifier']
            else:
                name = ''
            rowlist = [row_to_string(row) for row in array['row list']]
            return name + '{' + ';'.join(rowlist) + '}'
        elif 'struct' in thing:
            struct = thing['struct']
            if 'struct base' in struct:
                # FIXME this will fail for more elaborate structs.
                name = struct['struct base']['identifier']
            field = struct['field']['identifier']
            return name + '.' + field
        elif 'transpose' in thing:
            # Can't be called as LHS of an assignment, but we use make_key
            # for make_formula, and therefore need to do something sensible.
            trans = thing['transpose']
            return MatlabGrammar.make_key(trans['operand']) + trans['operator']
        elif 'function handle' in thing:
            # Can't be called as LHS of an assignment, but we use make_key
            # for make_formula, and therefore need to do something sensible.
            handle = thing['function handle']
            if 'name' in handle:
                return '@' + handle['name']
            else:
                # No name => anonymous function
                arg_list = row_to_string(handle['argument list'])
                body = MatlabGrammar.make_key(handle['function definition'])
                return '@(' + arg_list + ')' + body
        elif 'comment' in thing or 'function definition' in thing \
             or 'command' in thing or 'command statement' in thing:
            # No reason for make_key called for these things, but must catch
            # random mayhem before falling through to the final case.
            return None
        else:
            # The only thing left is expressions.
            list = [MatlabGrammar.make_formula(term, False) for term in thing]
            return '(' + ''.join(list) + ')'


    @staticmethod
    def make_formula(results, spaces=True, parens=True):
        '''Converted a mathematical expression into libSBML-style string form.
        The default behavior is to put spaces between terms and operators;
        if the optional flag 'spaces' is False, then no spaces are introduced.
        The default between is also to surround the expression with parentheses
        but if the optional flag 'parens' is False, the outermost parentheses
        are omitted.
        '''
        if 'identifier' in results:
            return results['identifier']
        elif 'number' in results:
            return results['number']
        elif 'boolean' in results:
            return results['boolean']
        elif 'string' in results:
            return results['string']
        elif 'tilde' in results:
            return '~'
        elif 'colon operator' in results:
            return ':'
        elif 'unary operator' in results:
            return results['unary operator']
        elif 'binary operator' in results:
            return results['binary operator']
        elif {'matrix', 'matrix or function', 'cell array', 'struct',
              'function handle', 'transpose'} & set(results.keys()):
            return MatlabGrammar.make_key(results)
        elif len(results) == 1 and results.keys() == 0:
            return make_formula(results[0])
        elif len(results) > 1:
            list = [MatlabGrammar.make_formula(term, spaces) for term in results]
            sep = ''
            if spaces:
                sep = ' '
            if parens:
                return '(' + sep.join(list) + ')'
            else:
                return sep.join(list)
        elif 'comment' in thing:
            return ''
        else:
            # The remaining cases are things like command statements.  Those
            # shouldn't end up being called for make_formula.  Rather than
            # raise an error, though, this just returns None and lets the
            # caller deal with the problem.
            return None



        # for c in results:
        #     if c.tag != 'function definition':
        #         continue
        #     print('')
        #     print('** scope: ' + c.scope.name + ' **')
        #     if len(c.scope.variables) > 0:
        #         print('    Variables assigned in this scope:')
        #         vars = c.scope.variables
        #         for name in vars.keys():
        #             value = vars[name]
        #             value_type = self._interpret_type(value)
        #             if value_type == 'bare matrix':
        #                 rows = len(value[0])
        #                 print('      ' + name + ' = (matrix with ' + str(rows) + ' rows)')
        #             elif value_type is None:
        #                 print('      ' + name + ' = ' + self._flatten(value.asList()))
        #             else:
        #                 print('      ' + name)

        #     else:
        #         print('    No variables defined in this scope.')
        #     if len(c.scope.functions) > 0:
        #         print('    Functions defined in this scope:')
        #         for fname, fscope in c.scope.functions.items():
        #             print('      ' + ' '.join(fscope.returns)
        #                   + ' = ' + fname + '(' + ' '.join(fscope.args) + ')')
        #     else:
        #         print('    No functions defined in this scope.')
