MOCCASIN MATLAB parser module
=============================

The Python module `matlab` in this directory defines a class, `MatlabGrammar`, that implements a parser for MATLAB files.  The parser is implemented using [PyParsing](http://pyparsing.wikispaces.com), a Python parsing framework.

First words and assumptions
---------------------------

MATLAB is a complex system, and the language is complex.  No parser can fully interpret MATLAB input except MATLAB.  MOCCASIN's parser is designed to parse a lot of the MATLAB language, but not all of it.  The goal of MOCCASIN is to allow interpretation and translation of certain kinds of MATLAB files common in MOCCASIN's domain; for this purpose, it does not need to handle all possible MATLAB inputs.  (In fact, it already exceeds the minimum it would really need, because the authors have a tendency to overdo things....)  In keeping with this standpoint, it's worth being upfront about the following:

* The parser is more permissive than MATLAB would be.  After all, the input is assumed to be valid MATLAB in the first place, so the parser implementation can afford to be a little bit looser and thus a little bit simpler.
* There is no support for imaginary numbers.  (In MOCCASIN's domain of application, imaginary numbers are never used.)

That said, we welcome anyone who would like to improve and expand the MATLAB parser in MOCCASIN.


Summary of basic usage principles
---------------------------------

The main entry point is `MatlabGrammar.parse_string()`.  There are a few other public methods on `MatlabGrammar` for debugging and other tasks, but the basic goal of `MatlabGrammar` is to provide `MatlabGrammar.parse_string()`, a function to produce a data structure that a caller can examine to determine what was found in a given MATLAB file.

First thing to know: the `ParseResults` objects generated by this PyParsing-based parser are heavily nested and annotated.  This is annoying to traverse by hand, and even more annoying to print (you will a *lot* of output for even simple things).  More on that below.

The second thing to note is that the grammar is designed to attach PyParsing "result names" to matched components.  What this means is that most ParseResults objects have a Python dictionary associated with them.  You can use Python's `keys()` operator to inspect the dictionary keys on most objects.  The basic approach to using the parsing results thus becomes a matter of using `keys()` to find out the entry or entries on an object, accessing the dictionary entries using the keys, calling `keys()` on the result of *that*, and so on, recursively.

Here's an example using a simple assignment.  Suppose a file contains this:

```matlab
    a = 1
```

`MatlabGrammar.parse_string()` will return one `ParseResults` object at the top level, but this object will in reality be a recursively-structured list of annotated `ParseResults` objects.  (This will hopefully become more clear as this example progresses.)  At the top level, there will be one object per line in the file.  To find out how many there are, you can look at the length of what was returned by `MatlabGrammar.parse_string()`:

```python
    (Pdb) type(results)
    <class 'pyparsing.ParseResults'>
    (Pdb) len(results)
    1
```

In this example, there's only one line in the file, so the length of the `ParseResults` object is one.  Let's get the `ParseResults` object for that first line:

```python
    (Pdb) content = results[0]
    (Pdb) content.keys()
    ['assignment']
```

This first line of the file was labeled as an `'assignment'`, which is `MatlabGrammar`'s way of identifying (you guessed it) an assignment statement.  Now let's look inside of it:

```python
    (Pdb) content['assignment'].keys()
    ['rhs', 'lhs']
```

The object stored under the dictionary key `'assignment'` has its own dictionary, and that dictionary has two entries: one under the key `'lhs'` (for the left-hand side of the assignment) and another under the key `'rhs'` (for the right-hand side).  You can access each of these individually:

```python
    (Pdb) content['assignment']['lhs'].keys()
    ['identifier']
```

This now says that the object keyed by `'lhs'` in the `content['assignment']` `ParseResults` object has another dictionary, with a single item stored under the key `'identifier'`.  `'identifier'` is one of the terminal entities in `MatlabGrammar`.  When you access its value, you will find it's not a `ParseResults` object, but a string:

```python
    (Pdb) content['assignment']['lhs']['identifier']
    'a'
```

And there it is: the name of the variable on the left-hand side of the assignment in the file.  If we repeat the process for the right-hand side of the assignment, we find the following:

```python
    (Pdb) content['assignment']['rhs'].keys()
    ['number']
    (Pdb) content['assignment']['rhs']['number']
    '1'
```

The key `'number'` corresponds to another terminal entity in `MatlabGrammar`.  Its value is (you guessed it again) a number.  Note that the values returned by `MatlabGrammar` are always strings, so even though it could in principle be returned in the form of a numerical data type, `MatlabGrammar` does not do that, because doing so might require data type conversions and such conversions might require decisions that are best left to the applications calling `MatlabGrammar`.  So instead, it always returns everything in finds in a MATLAB file as a text string.

Now, let's examine what happens if we have something slightly more complicated in the file, such as the following:

```matlab
    a = [1 2; 3 4]
```

This is an assignment to a matrix that has two rows, each of which have two items.  Applying `MatlabGrammar.parse_string()` to this input will once again yield a `ParseResults` object that itself contains a list of `ParseResults` objects, where the list will only have length one.  If we access the object,

```python
    (Pdb) content = results[0]
    (Pdb) content.keys()
    ['assignment']
```

we once again have an assignment, as expected.  Let's take a look at the right-hand side of this one:

```python
    (Pdb) content['assignment']['rhs'].keys()
    ['matrix']
```

This time, `MatlabGrammar` has helpfully identified the object on the right-hand side as a matrix.  Let's traverse the structure it produced:

```python
    (Pdb) matrix = content['assignment']['rhs']['matrix']
    (Pdb) matrix.keys()
    ['row list']
    (Pdb) matrix['row list'].keys()
    []
```

This time, the object has no keys.  The reason for this is the following: some objects stored under the dictionary keys are actually lists.  The name `'row list'` is meant to suggest this possibility.  When a value created by `MatlabGrammar` is a list, the first thing to do is to find out its length:

    (Pdb) len(matrix['row list'])
    2

What this means is that the matrix has two row entries stored in a list
keyed by `'row list'`.  Accessing them is simple:

```python
    (Pdb) row1 = matrix['row list'][0]
    (Pdb) row2 = matrix['row list'][1]
    (Pdb) row1.keys()
    ['subscript list']
    (Pdb) row2.keys()
    ['subscript list']
```

Both of them have lists of their own.  These work in the same way as the row lists: you first find out their length, and then index into them to get the values.

```python
    (Pdb) len(row1)
    2
    (Pdb) row1[0].keys()
    ['number']
    (Pdb) row1[0]['number']
    '1'
    (Pdb) row1[1].keys()
    ['number']
    (Pdb) row1[1]['number']
    '2'
```

As expected, we are down to the terminal parts of the expression, and here we have indexed into the first element of the first row of the matrix.  All of the rest of the entries in the matrix are accessed in the same way.  For example,

```python
    (Pdb) row2[1].keys()
    ['number']
    (Pdb) row2[1]['number']
    '4'
```

As a final example, let's take a look at a mathematical expression.
Suppose our file contains the following:

```matlab
    a = 1 + 2
```

As usual, applying ```MatlabGrammar.parse_string()` to this input will once again yield a `ParseResults` object that itself contains a list of `ParseResults` objects, and once again the list will only have length 1 because there is only one line in the file.  If we access the first object,

```python
    (Pdb) content = results[0]
    (Pdb) content.keys()
    ['assignment']
```

we once again have an assignment, as expected.  Let's take a look at the right-hand side of this one:

```python
    (Pdb) content['assignment']['rhs'].keys()
    []
```

This time, the right-hand side does not have a key.  This is the tip-off that the right-hand side is an expression: in `MatlabGrammar`, if there is no key on an object, it always means that _the object is either an expression or a list_.  And actually, expressions _are_ lists too: when you encounter an expression, it means the next step is to iterate over the elements.

```python
    (Pdb) len(content['assignment']['rhs'])
    3
    (Pdb) content['assignment']['rhs'][0].keys()
    ['number']
    (Pdb) content['assignment']['rhs'][1].keys()
    ['binary operator']
    (Pdb) content['assignment']['rhs'][2].keys()
    ['number']
```

In this simple expression, the elements inside the expression list are terminal objects, but in general, they could be anything, including more expressions.  The rule for traversing expressions is the same: inspect the keys of each object, do whatever is appropriate for kind of object it is, and if there are no keys, it's another expression, so traverse it recursively.

And that is the basic process for working with MatlabGrammar parse results.  In summary:

1. The function  `MatlabGrammar.parse_string()` returns a list of objects results for the lines in the file.  You iterate over each one.
2. Each has a dictionary, which you inspect to figure out what kind of objects were extracted.
3. You dig into the objects' dictionaries recursively until you reach terminal entities. Sometimes the values for dictionaries are lists, in which case you iterate over the values, applying the same principle.


Debugging aids
--------------

The parser module directory, `matlab`, contains a simple test driver in the form of the file `test.py`.  It accepts a MATLAB file as a required argument and a couple of optional arguments.  When executed, it parses the file using `MatlabGrammar.parse_string()` and prints an annotated representation of the interpreted input.  This representation is not particularly useful for anything except human inspection, but it does let you see what `MatlabGrammar.parse_string()` thought of a given input file.  If given the optional argument `-s`, the function invokes the Python `pdb` debugger after parsing the input, thus allowing you to inspect the resulting data structure interactively.

The `MatlabGrammar` class itself implements the printing facility in the form of two methods that callers can invoke if desired:

* `interpret_parse_results()`: takes as a single argument the output from `MatlabGrammar.parse_string()` and returns a string containing an annotated representation of the parse results.
* `print_parse_results`: takes as a single argument the output from `MatlabGrammar.parse_string()`, calls `interpret_parse_results()` on it, and prints the result using Python's regular `print()` function.


Parsed object types returned by MatlabGrammar
---------------------------------------------

### Terminal entities

The values of terminal entities are always strings, even if the item is a number or a single character such as `:`.

* 'identifier'
* 'number'
* 'string'
* 'boolean' 
* 'colon'
* 'tilde'
* 'colon operator'
* 'unary operator'
* 'binary operator'

### Structured data types

### Function calls

### Function definitions

### Expressions

### Flow control statements

### Commands and other statements


The `Scope` class and facility
------------------------------
