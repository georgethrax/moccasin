MOCCASIN MATLAB parser module
=============================

The Python module `matlab` in this directory defines a class, `MatlabGrammar`, that implements a parser for MATLAB files.  The parser is implemented using [PyParsing](http://pyparsing.wikispaces.com), a Python parsing framework.

Summary of basic principles
---------------------------

The main entry point is `MatlabGrammar.parse_string()`.  There are a few other public methods on `MatlabGrammar` for debugging and other tasks, but the basic goal of `MatlabGrammar` is to provide `MatlabGrammar.parse_string()`, a function to produce a data structure that a caller can examine to determine what was found in a given MATLAB file.

First thing to know: the `ParseResults` objects generated by this PyParsing-based parser are heavily nested and annotated.  This is annoying to traverse by hand, and even more annoying to print (you will a *lot* of output for even simple things).  More on that below.

The second thing to note is that the grammar is designed to attach PyParsing "result names" to matched components.  What this means is that most ParseResults objects have a Python dictionary associated with them.  You can use Python's `keys()` operator to inspect the dictionary keys on most objects.  The basic approach to using the parsing results thus becomes a matter of using `keys()` to find out the entry or entries on an object, accessing the dictionary entries using the keys, calling `keys()` on the result of *that*, and so on, recursively.

Here's an example using a simple assignment.  Suppose a file contains this:

```python
    a = 1
```

`MatlabGrammar.parse_string()` will return one `ParseResults` object at the top level, but this object will in reality be a recursively-structured list of annotated `ParseResults` objects.  (This will hopefully become more clear as this example progresses.)  At the top level, there will be one object per line in the file.  To find out how many there are, you can look at the length of what was returned by `MatlabGrammar.parse_string()`:

```python
    (Pdb) type(results)
    <class 'pyparsing.ParseResults'>
    (Pdb) len(results)
    1
```

In this example, there's only one line in the file, so the length of the `ParseResults` object is one.  Let's get the `ParseResults` object for that first line:

```python
    (Pdb) content = results[0]
    (Pdb) content.keys()
    ['assignment']
```

This first line of the file was labeled as an 'assignment', which is `MatlabGrammar`'s way of identifying (you guessed it) an assignment statement.  Now let's look inside of it:

```python
    (Pdb) content['assignment'].keys()
    ['rhs', 'lhs']
```

The object stored under the dictionary key `'assignment'` has its own dictionary, and that dictionary has two entries: one under the key `'lhs'` (for the left-hand side of the assignment) and another under the key `'rhs'` (for the right-hand side).  You can access each of these individually:

```python
    (Pdb) content['assignment']['lhs'].keys()
    ['identifier']
```

This now says that the object keyed by `'lhs'` in the `content['assignment']` `ParseResults` object has another dictionary, with a single item stored under the key `'identifier'`.  `'identifier'` is one of the terminal entities in `MatlabGrammar`.  When you access its value, you will find it's not a `ParseResults` object, but a string:

```python
    (Pdb) content['assignment']['lhs']['identifier']
    'a'
```

And there it is: the name of the variable on the left-hand side of the assignment in the file.  If we repeat the process for the right-hand side of the assignment, we find the following:

```python
    (Pdb) content['assignment']['rhs'].keys()
    ['number']
    (Pdb) content['assignment']['rhs']['number']
    '1'
```

The key `'number'` corresponds to another terminal entity in `MatlabGrammar`.  Its value is (you guessed it again) a number.  Note that the values returned by `MatlabGrammar` are always strings, so even though it could in principle be returned in the form of a numerical data type, `MatlabGrammar` does not do that, because doing so might require data type conversions and such conversions might require decisions that are best left to the applications calling `MatlabGrammar`.  So instead, it always returns everything in finds in a MATLAB file as a text string.

Now, let's examine what happens if we have something slightly more complicated in the file, such as the following:

```python
    a = [1 2; 3 4]
```

This is an assignment to a matrix that has two rows, each of which have two items.  Applying `MatlabGrammar.parse_string()` to this input will once again yield a `ParseResults` object that itself contains a list of `ParseResults` objects, where the list will only have length one.  If we access the object,

```python
    (Pdb) content = results[0]
    (Pdb) content.keys()
    ['assignment']
```

we once again have an assignment, as expected.  Let's take a look at the right-hand side of this one:

```python
    (Pdb) content['assignment']['rhs'].keys()
    ['matrix']
```

This time, `MatlabGrammar` has helpfully identified the object on the right-hand side as a matrix.  Let's traverse the structure it produced:

```python
    (Pdb) matrix = content['assignment']['rhs']['matrix']
    (Pdb) matrix.keys()
    ['row list']
    (Pdb) matrix['row list'].keys()
    []
```

This time, the object has no keys.  The reason for this is the following: some objects stored under the dictionary keys are actually lists.  The name `'row list'` is meant to suggest this possibility.  When a value created by `MatlabGrammar` is a list, the first thing to do is to find out its length:

    (Pdb) len(matrix['row list'])
    2

What this means is that the matrix has two row entries stored in a list
keyed by `'row list'`.  Accessing them is simple:

```python
    (Pdb) row1 = matrix['row list'][0]
    (Pdb) row2 = matrix['row list'][1]
    (Pdb) row1.keys()
    ['index list']
    (Pdb) row2.keys()
    ['index list']
```

Both of them have lists of their own.  These work in the same way as the row lists: you first find out their length, and then index into them to get the values.

```python
    (Pdb) len(row1)
    2
    (Pdb) row1[0].keys()
    ['number']
    (Pdb) row1[0]['number']
    '1'
```

As expected, we are down to the terminal parts of the expression, and here we have indexed into the first element of the first row of the matrix.  All of the rest of the entries in the matrix are accessed in the same way.  For example,

```python
    (Pdb) row2[1].keys()
    ['number']
    (Pdb) row2[1]['number']
    '4'
```

As a final example, let's take a look at a mathematical expression.
Suppose our file contains the following:

```python
    a = 1 + 2
```

As usual, applying ```MatlabGrammar.parse_string()` to this input will once again yield a `ParseResults` object that itself contains a list of `ParseResults` objects, and once again the list will only have length 1 because there is only one line in the file.  If we access the first object,

```python
    (Pdb) content = results[0]
    (Pdb) content.keys()
    ['assignment']
```

we once again have an assignment, as expected.  Let's take a look at the right-hand side of this one:

```python
    (Pdb) content['assignment']['rhs'].keys()
    []
```

This time, the right-hand side does not have a key.  This is the tip-off that the right-hand side is an expression: in `MatlabGrammar`, if there is no key on an object, it means that the object is an expression or a list.  Expressions are lists: when you encounter them, it means the next step is to iterate over the elements.

```python
    (Pdb) len(content['assignment']['rhs'])
    3
    (Pdb) content['assignment']['rhs'][0].keys()
    ['number']
    (Pdb) content['assignment']['rhs'][1].keys()
    ['binary operator']
    (Pdb) content['assignment']['rhs'][2].keys()
    ['number']
```

In this simple expression, the elements inside the expression list are terminal objects, but in general, they could be anything, including more expressions.  The rule for traversing expressions is the same: inspect the keys of each object, do whatever is appropriate for kind of object it is, and if there are no keys, it's another expression, so traverse it recursively.

And that summarizes the basic process for working with MatlabGrammar parse results.  `MatlabGrammar.parse_string()` returns a list of objects results for the lines in the file; each has a dictionary, which you inspect to figure out what kind of objects were extracted, and then you dig into the object's dictionaries recursively until you reach terminal entities.  Sometimes the values for dictionaries are lists, in which case you iterate over the values, applying the same principle.
